"""
Python銘柄スクリーナー（auカブコム kabuステーション® API）
08:55〜08:59:50 の間、東証プライム銘柄のAOIを10秒間隔で記録し、
最終時点の|AOI|が閾値以上かつ標準偏差が閾値以下の銘柄を抽出。
結果はコードのリストとして返却し、必要に応じてファイルへ出力。
"""

from __future__ import annotations

import csv
import time
import logging
from typing import List, Dict
from datetime import datetime
import numpy as np

import config
from .kabu_data_fetcher import KabuDataFetcher

logger = logging.getLogger(__name__)


class KabuScreener:
    def __init__(self) -> None:
        self.fetcher = KabuDataFetcher()
        self.aoi_history: Dict[str, List[float]] = {}

    def load_prime_codes(self) -> List[str]:
        path = config.PRIME_LIST_CSV
        try:
            codes: List[str] = []
            with open(path, newline='', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                # 期待カラム: Code
                for row in reader:
                    code = str(row.get('Code') or row.get('code') or '').strip()
                    if code:
                        codes.append(code)
            logger.info(f"東証プライム銘柄数: {len(codes)} (from {path})")
            return codes
        except FileNotFoundError:
            logger.error(f"プライム銘柄CSVが見つかりません: {path}")
            return []
        except Exception as e:
            logger.error(f"プライム銘柄CSV読み込みエラー: {e}")
            return []

    def scan(self, codes: List[str]) -> List[str]:
        if not codes:
            logger.error("銘柄コードが空です")
            return []
        if not self.fetcher.authenticate():
            logger.error("kabu API 認証失敗")
            return []

        # 時間窓
        start_time = datetime.now().replace(hour=8, minute=55, second=0, microsecond=0)
        end_time = datetime.now().replace(hour=8, minute=59, second=50, microsecond=0)

        now = datetime.now()
        if now < start_time:
            wait = (start_time - now).total_seconds()
            logger.info(f"スキャン開始まで {wait:.0f} 秒待機")
            time.sleep(max(0, wait))

        iteration = 0
        while datetime.now() <= end_time:
            iteration += 1
            logger.info(f"AOIスキャン {iteration} 回目")
            for code in codes:
                try:
                    board = self.fetcher.get_board(code)
                    if not board:
                        continue
                    aoi = KabuDataFetcher.calculate_aoi(board)
                    self.aoi_history.setdefault(code, []).append(aoi)
                except Exception as e:
                    logger.warning(f"{code} AOI取得エラー: {e}")
                    continue
            time.sleep(config.DATA_FETCH_INTERVAL)

        return self._select_codes()

    def _select_codes(self) -> List[str]:
        selected: List[str] = []
        for code, arr in self.aoi_history.items():
            if len(arr) < 3:
                continue
            final_aoi = arr[-1]
            std = float(np.std(arr))
            if abs(final_aoi) >= config.AOI_THRESHOLD and std <= config.AOI_STABILITY_THRESHOLD:
                selected.append(code)
                logger.info(f"選定: {code} AOI={final_aoi:.3f} std={std:.3f}")
        # AOI絶対値降順（最終値）
        selected.sort(key=lambda c: abs(self.aoi_history.get(c, [0])[-1]), reverse=True)
        return selected

    @staticmethod
    def format_list_for_copy(codes: List[str]) -> str:
        # クリップボードに貼りやすいPythonリスト表現
        return '[' + ', '.join(f"'{c}'" for c in codes) + ']'

    def write_watchlist(self, codes: List[str], path: str) -> None:
        try:
            with open(path, 'w', encoding='utf-8') as f:
                f.write('# Watchlist generated by KabuScreener\n')
                f.write('\n# Copy-friendly list\n')
                f.write(self.format_list_for_copy(codes) + '\n')
                f.write('\n# One per line\n')
                for c in codes:
                    f.write(c + '\n')
            logger.info(f"ウォッチリストを書き出しました: {path}")
        except Exception as e:
            logger.error(f"ウォッチリスト出力エラー: {e}")

